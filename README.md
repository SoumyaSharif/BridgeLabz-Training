## ğŸ”´ Week 5: Design Principles and Design Patterns

### ğŸ“… Day 1 â€“ Design Principles
**Date:** 2-Feb-2026 

Understanding fundamental software design principles for writing clean, maintainable, and scalable code.

#### SOLID Principles

1. **Single Responsibility Principle (SRP)**
   - A class should have only one reason to change
   - Each class should have a single, well-defined responsibility

2. **Open/Closed Principle (OCP)**
   - Software entities should be open for extension but closed for modification
   - Extend functionality without changing existing code

3. **Liskov Substitution Principle (LSP)**
   - Objects of a superclass should be replaceable with objects of its subclasses
   - Subtypes must be substitutable for their base types

4. **Interface Segregation Principle (ISP)**
   - Clients should not be forced to depend on interfaces they don't use
   - Create specific interfaces rather than one general-purpose interface

5. **Dependency Inversion Principle (DIP)**
   - High-level modules should not depend on low-level modules
   - Both should depend on abstractions

#### Additional Design Principles

6. **Don't Repeat Yourself (DRY)**
   - Avoid code duplication
   - Every piece of knowledge should have a single representation

7. **Keep It Simple, Stupid (KISS)**
   - Simplicity should be a key goal in design
   - Avoid unnecessary complexity

8. **You Aren't Gonna Need It (YAGNI)**
   - Don't add functionality until it's necessary
   - Implement things when you actually need them

---

### ğŸ“… Day 1 â€“ Multithreading
**Date:** 2-Feb-2026 

Mastering concurrent programming and parallel execution.

#### Key Topics

- **Thread Basics**
  - Creating and managing threads
  - Thread lifecycle and states
  
- **Synchronization**
  - Thread safety and race conditions
  - Locks and monitors
  - Deadlocks and how to avoid them

- **Concurrency Patterns**
  - Producer-Consumer pattern
  - Thread pools
  - Asynchronous programming

- **Best Practices**
  - Thread-safe data structures
  - Performance optimization
  - Common pitfalls and solutions

---

### ğŸ“… Day 2 â€“ Design Patterns
**Date:** 3-Feb-2026  

Learning Gang of Four (GoF) design patterns and UML modeling.

#### Categories of Patterns (GoF Classification)

Design patterns are divided into three main categories:

1. **Creational Patterns** - Object creation mechanisms
2. **Structural Patterns** - Object composition and relationships
3. **Behavioral Patterns** - Object interaction and responsibility

#### Covered Design Patterns

##### 1. **Singleton Pattern** ğŸ”
- **Type:** Creational
- **Purpose:** Ensure a class has only one instance
- **Use Case:** Database connections, logging, configuration managers

##### 2. **Factory Pattern** ğŸ­
- **Type:** Creational
- **Purpose:** Create objects without specifying exact class
- **Use Case:** Object creation with varying types, dependency injection

##### 3. **Observer Pattern** ğŸ‘€
- **Type:** Behavioral
- **Purpose:** Define one-to-many dependency between objects
- **Use Case:** Event handling, publish-subscribe systems, MVC architecture

##### 4. **Builder Pattern** ğŸ”¨
- **Type:** Creational
- **Purpose:** Construct complex objects step by step
- **Use Case:** Creating objects with many optional parameters

#### UML Designing ğŸ“

Understanding Unified Modeling Language for software design:

- **Class Diagrams**
  - Classes, attributes, and methods
  - Relationships (association, aggregation, composition, inheritance)
  
- **Sequence Diagrams**
  - Object interactions over time
  - Message flow between objects

- **Use Case Diagrams**
  - System functionality from user perspective
  - Actors and their interactions

- **Design Pattern UML**
  - Visual representation of each pattern
  - Component relationships and responsibilities

---

## ğŸ¯ Learning Objectives

### By the end of this schedule, you will be able to:

âœ… Apply SOLID principles to write maintainable code  
âœ… Implement thread-safe concurrent applications  
âœ… Recognize and apply common design patterns  
âœ… Create UML diagrams for software design  
âœ… Make informed architectural decisions  
âœ… Write cleaner, more professional code  

---
